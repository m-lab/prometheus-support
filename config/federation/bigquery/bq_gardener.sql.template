#standardSQL
-- bq_gardener calculates various metrics related to parser.Time.
-- Generally, "day" is used to refer to parse times, and "date" is used to refer to partitions.
--
-- Note: this query returns multiple values. So, resulting metrics will be:
--   bq_gardener_total_dates                         -- total number of date partitions in the table
--
--   bq_gardener_rows_per_date_last_4_dates          -- Average rows per date, last 3 or 4 dates
--   bq_gardener_rows_per_date_last_30_dates         -- Average rows per date, last 29 or 30 dates
--
--   bq_gardener_daily_done_last_4_days              -- Count of most recent daily dates.  Should be 3 or 4.
--
--   Dates with stale rows:
--   bq_gardener_dates_partially_parsed              -- Total
--   bq_gardener_dates_partially_parsed_last_day,    -- Parsed within past day.  Should be 0.
--   bq_gardener_dates_partially_parsed_last_7_days  -- Parsed within past 7 days.  Should be 0.
--   bq_gardener_dates_partially_parsed_last_30_days -- Parsed within past 30 days.  Should be 0.
--   bq_gardener_dates_partially_parsed_last_90_days -- Parsed within past 90 days.  Should be 0.
--
--   Dates without stale rows:
--   bq_gardener_dates_fully_parsed_last_day         -- Parsed within last day.
--   bq_gardener_dates_fully_parsed_last_7_days      -- Parsed within last 7 days.
--   bq_gardener_dates_fully_parsed_last_30_days     -- Parsed within last 30 days.
--   bq_gardener_dates_fully_parsed_last_90_days     -- Parsed within last 90 days.

WITH all_types AS (
  SELECT "raw_ndt.ndt7" AS datatype, id, date, parser.Time as parseTime,
  FROM `{{PROJECT}}.raw_ndt.ndt7`
  WHERE date > date('2019-01-01')
  UNION ALL
  SELECT "raw_ndt.ndt5" AS datatype, id, date, parser.Time as parseTime,
  FROM `{{PROJECT}}.raw_ndt.ndt5`
  WHERE date > date('2019-01-01')
  UNION ALL
  SELECT "raw_ndt.annotation2" AS datatype, id, date, parser.Time as parseTime,
  FROM `{{PROJECT}}.raw_ndt.annotation2`
  WHERE date > date('2019-01-01')
  UNION ALL
  SELECT "raw_ndt.hopannotation2" AS datatype, id, date, parser.Time as parseTime,
  FROM `{{PROJECT}}.raw_ndt.hopannotation2`
  WHERE date > date('2019-01-01')
  UNION ALL
  SELECT "raw_ndt.pcap" AS datatype, id, date, parser.Time as parseTime,
  FROM `{{PROJECT}}.raw_ndt.pcap`
  WHERE date > date('2019-01-01')
  UNION ALL
  SELECT "raw_ndt.scamper1" AS datatype, id, date, parser.Time as parseTime,
  FROM `{{PROJECT}}.raw_ndt.scamper1`
  WHERE date > date('2019-03-28')
  UNION ALL
  -- ndt.ndt7 is generated by gardener by joining the raw ndt7 and raw annotation tables.
  SELECT "ndt.ndt7" AS datatype, id, date, parser.Time as parseTime,
  FROM `{{PROJECT}}.ndt.ndt7`
  WHERE date > date('2019-01-01')
  UNION ALL
  -- ndt.ndt5 is generated by gardener by joining the raw ndt5 and raw annotation tables.
  SELECT "ndt.ndt5" AS datatype, id, date, parser.Time as parseTime,
  FROM `{{PROJECT}}.ndt.ndt5`
  WHERE date > date('2019-01-01')
  UNION ALL
  -- ndt.scamper1 is generated by gardener by joining the raw scamper1 and raw annotation tables.
  SELECT "ndt.scamper1" AS datatype, id, date, parser.Time as parseTime,
  FROM `{{PROJECT}}.ndt.scamper1`
  WHERE date > date('2019-03-28')
  UNION ALL
  SELECT "raw_utilization.switch" AS datatype, id, date, parser.Time as parseTime,
  FROM `{{PROJECT}}.raw_utilization.switch`
  WHERE date > date('2015-11-19')
  UNION ALL
  SELECT "raw_ndt.tcpinfo" AS datatype, id, date, parser.Time as parseTime,
  FROM `{{PROJECT}}.raw_ndt.tcpinfo`
  WHERE date > DATE('2019-01-01')
  UNION ALL
  SELECT "ndt.tcpinfo" AS datatype, id, date, parser.Time as parseTime,
  FROM `{{PROJECT}}.ndt.tcpinfo`
  WHERE date > DATE('2019-01-01')
  UNION ALL
  SELECT "raw_wehe.annotation2" AS datatype, id, date, parser.Time as parseTime,
  FROM `{{PROJECT}}.raw_wehe.annotation2`
  WHERE date > DATE('2019-01-01')
  UNION ALL
  SELECT "raw_wehe.hopannotation2" AS datatype, id, date, parser.Time as parseTime,
  FROM `{{PROJECT}}.raw_wehe.hopannotation2`
  WHERE date > DATE('2019-01-01')
  UNION ALL
  SELECT "wehe.scamper1" AS datatype, id, date, parser.Time as parseTime,
  FROM `{{PROJECT}}.wehe.scamper1`
  WHERE date > DATE('2019-01-01')
  UNION ALL
  SELECT "raw_msak.tcpinfo" as datatype, id, date, parser.Time as parseTime,
  FROM `{{PROJECT}}.raw_msak.tcpinfo`
  WHERE date > DATE('2023-01-01')
  UNION ALL
  SELECT "raw_msak.pcap" as datatype, id, date, parser.Time as parseTime,
  FROM `{{PROJECT}}.raw_msak.pcap`
  WHERE date > DATE('2023-01-01')
  UNION ALL
  SELECT "raw_msak.scamper1" as datatype, id, date, parser.Time as parseTime,
  FROM `{{PROJECT}}.raw_msak.scamper1`
  WHERE date > DATE('2023-01-01')
  UNION ALL
  SELECT "raw_msak.annotation2" as datatype, id, date, parser.Time as parseTime,
  FROM `{{PROJECT}}.raw_msak.annotation2`
  WHERE date > DATE('2023-01-01')
  UNION ALL
  SELECT "raw_msak.hopannotation2" as datatype, id, date, parser.Time as parseTime,
  FROM `{{PROJECT}}.raw_msak.hopannotation2`
  WHERE date > DATE('2023-01-01')
  UNION ALL
  SELECT "msak.scamper1" as datatype, id, date, parser.Time as parseTime,
  FROM `{{PROJECT}}.msak.scamper1`
  WHERE date > DATE('2023-01-01')
  UNION ALL
  SELECT "msak.tcpinfo" as datatype, id, date, parser.Time as parseTime,
  FROM `{{PROJECT}}.msak.tcpinfo`
  WHERE date > DATE('2023-01-01')
),

basic_stats AS (
  SELECT
    datatype,
    date,
    COUNT(id) AS rowCount,
    MAX(parseTime) AS max_parse_time,
    MIN(parseTime) AS min_parse_time,
    TIMESTAMP_DIFF(CURRENT_TIMESTAMP(), MAX(parseTime), HOUR) AS age_of_latest_parse,
    -- Worst case for parsing a single date (for tcpinfo) is currently about 5 hours.
    -- As a general policy, we should work to keep this below 24 hours.  Then the maximum
    -- span of parse dates observed in a date partition should be 24 hours.  If more than
    -- this, there are most likely stale rows from a previous reprocessing pass.
    TIMESTAMP_DIFF(MAX(parseTime), MIN(parseTime), HOUR) > 24 AS has_stale_rows,
    DATE_DIFF(CURRENT_DATE(), date, DAY) <= 4 AS last_4_dates,
    DATE_DIFF(CURRENT_DATE(), date, DAY) <= 30 AS last_30_dates,
  FROM
    all_types
  GROUP BY datatype, date
)

SELECT
  datatype,
  COUNT(date) AS value_total_dates,

  CAST(SAFE_DIVIDE(SUM(IF(last_4_dates, rowCount, 0)),
                   COUNTIF(last_4_dates)) AS INT64) AS value_rows_per_date_last_4_dates,
  CAST(SAFE_DIVIDE(SUM(IF(last_30_dates, rowCount, 0)),
                   COUNTIF(last_30_dates)) AS INT64) AS value_rows_per_date_last_30_dates,

  COUNTIF(age_of_latest_parse < 4*24 AND last_4_dates) AS value_daily_done_last_4_days,

  COUNTIF(has_stale_rows) AS value_dates_partially_parsed,
  COUNTIF(has_stale_rows AND age_of_latest_parse < 24) AS value_dates_partially_parsed_last_day,
  COUNTIF(has_stale_rows AND age_of_latest_parse < 7*24) AS value_dates_partially_parsed_last_7_days,
  COUNTIF(has_stale_rows AND age_of_latest_parse < 30*24) AS value_dates_partially_parsed_last_30_days,
  COUNTIF(has_stale_rows AND age_of_latest_parse < 90*24) AS value_dates_partially_parsed_last_90_days,

  COUNTIF(NOT has_stale_rows AND age_of_latest_parse < 24) AS value_dates_fully_parsed_last_day,
  COUNTIF(NOT has_stale_rows AND age_of_latest_parse < 7*24) AS value_dates_fully_parsed_last_7_days,
  COUNTIF(NOT has_stale_rows AND age_of_latest_parse < 30*24) AS value_dates_fully_parsed_last_30_days,
  COUNTIF(NOT has_stale_rows AND age_of_latest_parse < 90*24) AS value_dates_fully_parsed_last_90_days,
FROM
  basic_stats
GROUP BY datatype
ORDER BY datatype
